pipeline {
    agent any

    environment {
        // Define credential IDs used in the pipeline
        DB_CRED_ID = 'DB_CRED'
        MATTERMOST_WEBHOOK_ID = 'MATTERMOST_WEBHOOK'
        // Default build success flag
        IMAGE_BUILD_SUCCESS = "false"
    }

    stages {
        stage('Check Required Credentials') {
            steps {
                script {
                    def checkCredentialExists = { credId, credType ->
                        try {
                            withCredentials([file(credentialsId: credId, variable: 'CRED_FILE_CHECK')]) {
                                echo "‚úÖ Credential '${credId}' (${credType}) found."
                            }
                        } catch (e) {
                            error "‚ùå Critical Credential Missing: Cannot find '${credId}' (${credType}). Please configure it in Jenkins."
                        }
                    }
                    checkCredentialExists(env.DB_CRED_ID, 'Secret File (JSON)')
                    checkCredentialExists(env.MATTERMOST_WEBHOOK_ID, 'Secret Text')
                }
            }
        }

        stage('Generate .env files') {
            steps {
                script {
                    withCredentials([file(credentialsId: env.DB_CRED_ID, variable: 'DB_CRED_FILE')]) {
                        def creds = readJSON file: DB_CRED_FILE

                        // Generate .env for lightreborn
                        def lightrebornEnvCreds = creds['lightreborn']
                        if (!lightrebornEnvCreds) {
                            error "‚ùå Lightreborn configuration not found in DB_CRED.json"
                        }

                        // Generate Spring Datasource URL for lightreborn
                        lightrebornEnvCreds['SPRING_DATASOURCE_URL'] = "jdbc:postgresql://${lightrebornEnvCreds['POSTGRES_HOST']}:${lightrebornEnvCreds['POSTGRES_PORT']}/${lightrebornEnvCreds['POSTGRES_DB']}"
                        lightrebornEnvCreds['SPRING_DATASOURCE_USERNAME'] = lightrebornEnvCreds['POSTGRES_USER']
                        lightrebornEnvCreds['SPRING_DATASOURCE_PASSWORD'] = lightrebornEnvCreds['POSTGRES_PASSWORD']

                        def lightrebornEnvLines = lightrebornEnvCreds.collect { key, value -> "${key}=${value}" }
                        def lightrebornEnvContent = "# Generated by Jenkins for lightreborn\n" + lightrebornEnvLines.join('\n')

                        writeFile file: 'lightreborn.env', text: lightrebornEnvContent, encoding: 'UTF-8'
                        echo "‚úÖ lightreborn.env file generated using DB_CRED.json"

                        // Generate .env for dearie
                        def dearieEnvCreds = creds['dearie']
                        if (!dearieEnvCreds) {
                            error "‚ùå Dearie configuration not found in DB_CRED.json"
                        }

                        // Generate Spring Datasource URL for dearie
                        dearieEnvCreds['SPRING_DATASOURCE_URL'] = "jdbc:postgresql://${dearieEnvCreds['POSTGRES_HOST']}:${dearieEnvCreds['POSTGRES_PORT']}/${dearieEnvCreds['POSTGRES_DB']}"
                        dearieEnvCreds['SPRING_DATASOURCE_USERNAME'] = dearieEnvCreds['POSTGRES_USER']
                        dearieEnvCreds['SPRING_DATASOURCE_PASSWORD'] = dearieEnvCreds['POSTGRES_PASSWORD']

                        def dearieEnvLines = dearieEnvCreds.collect { key, value -> "${key}=${value}" }
                        def dearieEnvContent = "# Generated by Jenkins for dearie\n" + dearieEnvLines.join('\n')

                        writeFile file: 'dearie.env', text: dearieEnvContent, encoding: 'UTF-8'
                        echo "‚úÖ dearie.env file generated using DB_CRED.json"
                    }
                }
            }
        }

        stage('Build and Deploy Lightreborn') {
            steps {
                script {
                    try {
                        // Copy .env to frontend build context
                        echo "‚ÑπÔ∏è Copying lightreborn.env to ./lightreborn/frontend/ for build context..."
                        sh 'cp lightreborn.env ./lightreborn/frontend/.env'

                        // Build and deploy lightreborn services
                        echo "üöÄ Starting docker-compose up --build for lightreborn..."
                        sh "docker-compose --env-file lightreborn.env up -d --build"
                        env.IMAGE_BUILD_SUCCESS = "true"
                        echo "‚úÖ Docker Compose build and run successful for lightreborn services."
                    } catch (Exception e) {
                        env.IMAGE_BUILD_SUCCESS = "false"
                        currentBuild.result = 'FAILURE'
                        error "‚ùå Docker Compose failed for lightreborn: ${e.getMessage()}"
                    }
                }
            }
        }

        stage('Build and Deploy Dearie') {
            steps {
                script {
                    try {
                        // Build and deploy dearie services
                        echo "üöÄ Starting docker-compose up --build for dearie..."
                        sh "docker-compose --env-file dearie.env up -d --build dearie-backend"
                        env.IMAGE_BUILD_SUCCESS = "true"
                        echo "‚úÖ Docker Compose build and run successful for dearie services."
                    } catch (Exception e) {
                        env.IMAGE_BUILD_SUCCESS = "false"
                        currentBuild.result = 'FAILURE'
                        error "‚ùå Docker Compose failed for dearie: ${e.getMessage()}"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                def notifyMattermost = { String message ->
                    try {
                        def payload = groovy.json.JsonOutput.toJson([text: message])
                        writeFile file: 'payload.json', text: payload, encoding: 'UTF-8'

                        withCredentials([string(credentialsId: env.MATTERMOST_WEBHOOK_ID, variable: 'MATTERMOST_WEBHOOK_URL')]) {
                            echo " M Sending notification to Mattermost..."
                            sh(
                                script: """
                                    curl -X POST -H 'Content-Type: application/json; charset=utf-8' --data @payload.json "${MATTERMOST_WEBHOOK_URL}"
                                """,
                                label: 'Send Mattermost Notification'
                            )
                        }
                    } catch (credErr) {
                        echo "‚ö†Ô∏è Failed to send Mattermost notification: Could not load credential '${env.MATTERMOST_WEBHOOK_ID}' or webhook failed. ${credErr.getMessage()}"
                    } catch (e) {
                        echo "‚ö†Ô∏è Failed to send Mattermost notification: ${e.getMessage()}"
                    }
                }

                def jobName = env.JOB_NAME ?: 'Unknown Job'
                def buildNumber = env.BUILD_NUMBER ?: 'N/A'
                def buildUrl = env.BUILD_URL ?: '#'
                def finalStatus = currentBuild.result ?: 'UNKNOWN'
                def statusEmoji = (finalStatus == 'SUCCESS') ? '‚úÖ' : '‚ùå'
                def statusText = (finalStatus == 'SUCCESS') ? 'ÏÑ±Í≥µ' : 'Ïã§Ìå®'

                def message = """
                ${statusEmoji} *Jenkins Build ${statusText}*
                - **Project**: lightreborn & dearie
                - **Job**: ${jobName}
                - **Build**: #${buildNumber}
                - **Status**: ${finalStatus}
                - **Link**: [View Build](${buildUrl})
                """.stripIndent()

                if (finalStatus != 'SUCCESS' && env.IMAGE_BUILD_SUCCESS == "false") {
                    message += "\n- **Reason**: Docker Compose build/run failed."
                } else if (finalStatus != 'SUCCESS') {
                    message += "\n- **Reason**: Failure occurred in stage: ${currentBuild.currentResult}"
                }

                notifyMattermost(message)

                // Cleanup workspace
                echo "üßπ Cleaning up workspace..."
                sh 'rm -f lightreborn.env'
                sh 'rm -f dearie.env'
                sh 'rm -f ./lightreborn/frontend/.env'
                sh 'rm -f payload.json'
                echo "‚úÖ Cleanup complete."
            }
        }
    }
}
